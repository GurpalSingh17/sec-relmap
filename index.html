<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Relationship Map — SEC CSV Viewer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

<style>
:root{
  /* PwC-ish palette */
  --bg:#FAF9F7; --card:#FFFFFF; --ink:#2D2D2C; --muted:#6B6F72; --line:#E5E1DC;
  --accent:#D04A02; --parent:#D04A02; --child:#00A3A1; --link:#C8C4BE;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
header{padding:16px 18px;border-bottom:1px solid var(--line);position:sticky;top:0;background:linear-gradient(180deg,#fff,rgba(255,255,255,.92));backdrop-filter:blur(6px);z-index:3}
h1{margin:0 0 6px;font-size:20px}
.small{color:var(--muted);font-size:13px}
.row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;align-items:center}
button,.pill{padding:8px 12px;border-radius:10px;border:1px solid var(--line);background:#fff;color:var(--ink);cursor:pointer}
button:hover{border-color:var(--accent)}
input[type="file"]{display:none}
label[for="file"]{padding:8px 12px;border-radius:10px;border:1px dashed var(--line);background:#fff;cursor:pointer}
#drop{border:1px dashed var(--line);border-radius:12px;background:#fff;padding:10px 12px}
.help{color:var(--muted);font-size:12px}

.tabs{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
.tab{padding:8px 12px;border-radius:10px;border:1px solid var(--line);background:#fff;color:var(--ink);cursor:pointer}
.tab.active{border-color:var(--accent);box-shadow:0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent)}
.controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;align-items:center}
input[type="search"]{flex:1;min-width:260px;padding:10px 12px;border-radius:10px;border:1px solid var(--line);background:#fff;color:var(--ink)}
select{padding:9px 10px;border-radius:10px;border:1px solid var(--line);background:#fff;color:var(--ink)}

.view{display:none}
.view.active{display:block}
.section{padding:18px}
.card{border:1px solid var(--line);border-radius:14px;background:var(--card);padding:8px 12px;margin-bottom:12px}
summary{list-style:none;cursor:pointer;display:flex;align-items:center;gap:10px}
summary::-webkit-details-marker{display:none}
.parent-name{font-weight:600}
.cik{color:var(--muted)}
.badge{background:color-mix(in srgb, var(--accent) 12%, white);color:var(--accent);padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid color-mix(in srgb, var(--accent) 30%, white)}
.inner{padding:10px 4px 14px}
table{width:100%;border-collapse:collapse;font-size:13px}
th,td{border-bottom:1px solid var(--line);padding:8px 6px;vertical-align:top}
th{text-align:left;color:#474B4E;position:sticky;top:118px;background:var(--card)}
td.src a{color:#0B6DAA;text-decoration:none}
.hidden{display:none !important}
footer{padding:12px 18px;color:var(--muted);border-top:1px solid var(--line)}

/* Graph view */
#graph-wrap{height:calc(100vh - 230px);position:relative;border-top:1px solid var(--line);margin-top:10px}
#graph{width:100%;height:100%;background:#FFF}
.legend{position:absolute;left:12px;top:12px;background:#fff;border:1px solid var(--line);border-radius:10px;padding:8px 10px;font-size:12px;box-shadow:0 4px 10px rgba(0,0,0,.05)}
.legend .dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
.dot.parent{background:var(--parent)}
.dot.child{background:var(--child)}
.tooltip{position:absolute;background:#fff;color:var(--ink);font-size:12px;border:1px solid var(--line);border-radius:8px;padding:8px 10px;pointer-events:none;transform:translate(-50%,-120%);white-space:nowrap;display:none;z-index:5;box-shadow:0 8px 18px rgba(0,0,0,.08)}
#graph-controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
.mode-pill{border-color:var(--accent)}
</style>
</head>
<body>
<header>
  <h1>Relationship Map</h1>
  <div class="small">Parents: <span id="stat-parents">0</span> · Links: <span id="stat-links">0</span></div>

  <div class="row">
    <label for="file">Choose CSV</label><input id="file" type="file" accept=".csv,text/csv"/>
    <div id="drop">…or drop CSV here</div>
    <span class="help">Needs <code>Parent Entity Name</code> and <code>Child Entity</code> (or <code>Issuer Name</code>).</span>
  </div>

  <div class="tabs">
    <button class="tab active" data-target="#view-list">List view</button>
    <button class="tab" data-target="#view-graph">Graph view</button>
  </div>

  <!-- List controls -->
  <div class="controls" id="list-controls">
    <input id="q" type="search" placeholder="Search parent name…"/>
    <button id="expand">Expand all</button>
    <button id="collapse">Collapse all</button>
    <span class="help">No data leaves your browser.</span>
  </div>

  <!-- Graph controls -->
  <div id="graph-controls" class="controls" style="display:none">
    <span class="pill mode-pill">Mode:</span>
    <button id="mode-overview" class="pill">Overview</button>
    <button id="mode-focus" class="pill">Focus parent</button>
    <button id="mode-network" class="pill">Network (clustered)</button>
    <label class="pill">Top parents
      <select id="net-count">
        <option>20</option><option selected>50</option><option>100</option><option>200</option>
      </select>
    </label>
    <select id="parent-select" title="Choose parent (Focus mode)"></select>
    <button id="rerun">Re-run layout</button>
    <button id="fit">Fit</button>
  </div>
</header>

<main>
  <section id="view-list" class="view active section"><div class="help">Load a CSV to see grouped results.</div></section>

  <section id="view-graph" class="view section">
    <div id="graph-wrap">
      <canvas id="graph"></canvas>
      <div class="legend"><span class="dot parent"></span>Parent · <span class="dot child"></span>Child</div>
      <div id="tip" class="tooltip"></div>
    </div>
  </section>
</main>

<footer>
  Generated <span id="gen-ts"></span>
  · Last push: <span id="gh-push">loading…</span>
</footer>

<script>
document.getElementById('gen-ts').textContent = new Date().toISOString().slice(0,19).replace('T',' ');

// ---------- Tabs ----------
const tabs = document.querySelectorAll('.tab');
tabs.forEach(t => t.addEventListener('click', () => {
  tabs.forEach(x => x.classList.remove('active'));
  t.classList.add('active');
  document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
  document.querySelector(t.dataset.target).classList.add('active');

  const onGraph = (t.dataset.target==="#view-graph");
  document.getElementById('list-controls').style.display = onGraph ? "none" : "flex";
  document.getElementById('graph-controls').style.display = onGraph ? "flex" : "none";
  if (onGraph && window.__graph_on_activate) window.__graph_on_activate();
}));

// ---------- CSV ingest ----------
const fileInput = document.getElementById('file');
const drop = document.getElementById('drop');
drop.addEventListener('dragover', e => { e.preventDefault(); drop.style.borderColor='var(--accent)'; });
drop.addEventListener('dragleave', () => drop.style.borderColor='var(--line)');
drop.addEventListener('drop', e => {
  e.preventDefault(); drop.style.borderColor='var(--line)';
  const f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) loadFile(f);
});
fileInput.addEventListener('change', e => { const f = e.target.files[0]; if (f) loadFile(f); });

function loadFile(file){
  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    transformHeader: h => (h||"").trim(),
    complete: (res) => handleData(res.meta.fields, res.data),
    error: (err) => alert("CSV parse error: " + err)
  });
}

// ---------- Data prep ----------
let CURRENT = null;

function pickCol(cols, ...cands){
  const lc = {}; cols.forEach(c => lc[(c||'').toLowerCase()] = c);
  for (const c of cands){ if (lc[c?.toLowerCase()]) return lc[c.toLowerCase()]; }
  const compact = {}; cols.forEach(c => compact[(c||'').toLowerCase().replace(/\s+/g,'')] = c);
  for (const c of cands){ const k=(c||'').toLowerCase().replace(/\s+/g,''); if (compact[k]) return compact[k]; }
  return null;
}

function handleData(headers, rows){
  const col_parent_name = pickCol(headers,"Parent Entity Name");
  const col_parent_cik  = pickCol(headers,"Parent Entity CIK");
  const col_child       = pickCol(headers,"Child Entity","Issuer Name");
  const col_child_cik   = pickCol(headers,"Child Entity CIK","CIK");
  const col_entity_type = pickCol(headers,"Entity Type");
  const col_industry    = pickCol(headers,"Industry Group");
  const col_juris       = pickCol(headers,"Jurisdiction");
  const col_date        = pickCol(headers,"Filing Date","signatureDate");
  const col_clar        = pickCol(headers,"Clarification","relationshipClarification");
  const col_source      = pickCol(headers,"Source File");

  if (!col_parent_name || !col_child){
    alert("Missing required headers. Need at least 'Parent Entity Name' and 'Child Entity' (or 'Issuer Name').");
    return;
  }

  const byParent = new Map();
  for (const r of rows){
    const p = (r[col_parent_name]||"").trim();
    const c = (r[col_child]||"").trim();
    if (!p || !c) continue;
    const rec = {
      child     : c,
      child_cik : (r[col_child_cik]||"").trim(),
      etype     : (r[col_entity_type]||"").trim(),
      industry  : (r[col_industry]||"").trim(),
      juris     : (r[col_juris]||"").trim(),
      date      : (r[col_date]||"").trim(),
      clar      : (r[col_clar]||"").trim(),
      src       : (r[col_source]||"").trim()
    };
    if (!byParent.has(p)) byParent.set(p, { parent:p, parent_cik:(r[col_parent_cik]||"").trim(), children:[] });
    byParent.get(p).children.push(rec);
  }

  const groups = Array.from(byParent.values())
    .map(g => ({...g, count:g.children.length, children:g.children.sort((a,b)=>(a.date<b.date?1:a.date>b.date?-1:a.child.localeCompare(b.child)))}))
    .sort((a,b)=> b.count - a.count || a.parent.localeCompare(b.parent));

  document.getElementById('stat-parents').textContent = groups.length;
  document.getElementById('stat-links').textContent = rows.length;

  // List rendering
  document.getElementById('view-list').innerHTML = groups.map(renderGroup).join('');
  window.cards = Array.from(document.querySelectorAll('.card'));
  const q = document.getElementById('q'); q.value=''; q.dispatchEvent(new Event('input'));

  // Graph data
  const nodes = {};
  const linksMap = new Map();
  function nk(kind, name){ return kind + "|" + (name||"").trim(); }

  for (const g of groups){
    const pk = nk("P", g.parent);
    if (!nodes[pk]) nodes[pk] = { id:pk, label:g.parent, group:"parent", cik:g.parent_cik||"", count:g.count };
    for (const ch of g.children){
      const ck = nk("C", ch.child);
      if (!nodes[ck]) nodes[ck] = { id:ck, label:ch.child, group:"child", cik:ch.child_cik||"" };
      linksMap.set(pk+"||"+ck, (linksMap.get(pk+"||"+ck)||0)+1);
    }
  }
  const links = Array.from(linksMap.entries()).map(([k,cnt])=>{
    const [pk,ck] = k.split("||"); return { source:pk, target:ck, count:cnt };
  });

  CURRENT = { groups, nodes:Object.values(nodes), links };

  // Populate parent select
  const sel = document.getElementById('parent-select');
  sel.innerHTML = `<option value="">— choose parent —</option>` + groups.map(g => `<option>${escapeHtml(g.parent)}</option>`).join('');

  if (window.__graph_reload) window.__graph_reload(CURRENT);
}

function escapeHtml(s){return (s||"").replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}
function renderRow(r){
  const link = r.src ? `<a href="${escapeHtml(r.src)}" target="_blank" rel="noopener noreferrer">${escapeHtml(r.src)}</a>` : "";
  return `<tr>
    <td>${escapeHtml(r.child)}</td>
    <td>${escapeHtml(r.child_cik)}</td>
    <td>${escapeHtml(r.date)}</td>
    <td>${escapeHtml(r.juris)}</td>
    <td>${escapeHtml(r.etype)}</td>
    <td>${escapeHtml(r.industry)}</td>
    <td>${escapeHtml(r.clar)}</td>
    <td class="src">${link}</td>
  </tr>`;
}
function renderGroup(g){
  const rows = g.children.map(renderRow).join('');
  const cik  = g.parent_cik ? ` · <span class="cik">CIK: ${escapeHtml(g.parent_cik)}</span>` : '';
  return `
<details class="card" data-parent="${escapeHtml(g.parent).toUpperCase()}">
  <summary><span class="parent-name">${escapeHtml(g.parent)}</span>${cik} <span class="badge">${g.count}</span></summary>
  <div class="inner">
    <table>
      <thead>
        <tr>
          <th>Child Entity</th><th>Child CIK</th><th>Filing Date</th><th>Jurisdiction</th>
          <th>Entity Type</th><th>Industry Group</th><th>Clarification</th><th>Source</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
  </div>
</details>`;
}

// List search/expand
const q = document.getElementById('q');
q.addEventListener('input', ()=>{
  const term = (q.value||'').trim().toUpperCase();
  let shown = 0;
  for (const c of (window.cards||[])){
    const name = c.dataset.parent || '';
    const hit = !term || name.includes(term);
    c.classList.toggle('hidden', !hit);
    if (hit) shown++;
  }
  document.getElementById('stat-parents').textContent = shown || (CURRENT ? CURRENT.groups.length : 0);
});
document.getElementById('expand').addEventListener('click', ()=>{ for (const c of (window.cards||[])) c.open = true; });
document.getElementById('collapse').addEventListener('click', ()=>{ for (const c of (window.cards||[])) c.open = false; });
</script>

<script>
/* ===== Graph (Overview + Focus + Network clustered via d3-force) ===== */
(function(){
  const canvas = document.getElementById('graph');
  const ctx = canvas.getContext('2d', { alpha:false });
  const tip = document.getElementById('tip');

  // Offscreen context for measuring text widths
  const measure = document.createElement('canvas').getContext('2d');
  const baseFont = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  measure.font = baseFont;

  let nodes = [], links = [];
  let mode = 'overview';         // 'overview' | 'focus' | 'network'
  let scale=1, tx=0, ty=0;       // zoom/pan
  let dragging=null, dragOffset=[0,0], panning=false, panStart=[0,0], panOrig=[0,0];

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  function resize(){ canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
  window.addEventListener('resize', ()=>{ resize(); layout(); });
  window.__graph_on_activate = () => { resize(); };

  window.__graph_reload = (data) => {
    window.__DATA = data;
    mode = 'overview';
    buildOverview();
    fitScreen();
  };

  // ---------- builders ----------
  function buildOverview(){
    const parents = window.__DATA.nodes
      .filter(n=>n.group==='parent')
      .sort((a,b)=> b.count - a.count || a.label.localeCompare(b.label))
      .map(n => ({ ...n, size: clamp(6 + 6*Math.log10((n.count||1)+1), 6, 18) }));

    nodes = parents;
    links = [];
    layoutOverview();
  }

  function buildFocus(parentLabel){
    const p = window.__DATA.nodes.find(n => n.group==='parent' && n.label===parentLabel);
    if (!p){ buildOverview(); return; }

    const childrenIds = new Set(
      window.__DATA.links.filter(e => e.source===("P|"+parentLabel)).map(e=>e.target)
    );
    const kids = window.__DATA.nodes.filter(n => childrenIds.has(n.id));

    nodes = [{...p, size:12}, ...kids.map(k=>({...k, size:7}))];
    links = kids.map(k => ({ source:nodes[0], target:k, w:1 }));

    layoutFocusNoOverlap();
  }

  // d3-force clustered network (top N parents + their children)
  let sim = null;
  function buildNetwork(topN){
    sim && sim.stop();

    const parents = window.__DATA.groups.slice(0, topN);
    const nodeMap = new Map();

    const getNode = (id, label, group, size, cik, count) => {
      if (!nodeMap.has(id)) nodeMap.set(id, { id, label, group, size, cik, count });
      return nodeMap.get(id);
    };

    const edges = [];
    for (const g of parents){
      const pid = "P|" + g.parent;
      const p = getNode(pid, g.parent, "parent", 8, g.parent_cik||"", g.count);
      for (const ch of g.children){
        const cid = "C|" + ch.child;
        const c  = getNode(cid, ch.child, "child", 5, ch.child_cik||"", 1);
        edges.push({ source: p.id, target: c.id });
      }
    }

    const simNodes = Array.from(nodeMap.values());
    const simLinks = edges;

    // run force simulation
    sim = d3.forceSimulation(simNodes)
      .force('link', d3.forceLink(simLinks).id(d=>d.id).distance(d => d.group==='parent' ? 80 : 55).strength(0.4))
      .force('charge', d3.forceManyBody().strength(-70))
      .force('collide', d3.forceCollide().radius(d => (d.size||6) + 3))
      .force('center', d3.forceCenter(0,0))
      .stop();

    // do a fixed number of ticks then freeze
    for (let i=0;i<350;i++) sim.tick();

    // plug into renderer
    nodes = simNodes;
    links = simLinks.map(l => ({ source: nodeMap.get(l.source.id||l.source), target: nodeMap.get(l.target.id||l.target) }));
  }

  // ---------- layouts ----------
  function layout(){ 
    if (mode==='overview') layoutOverview();
    else if (mode==='focus') layoutFocusNoOverlap();
    // network uses force layout positions already
  }

  function layoutOverview(){
    const cw = canvas.width, ch = canvas.height, pad=60;
    const n = nodes.length; if (!n) return;
    const cols = Math.ceil(Math.sqrt(n));
    const rows = Math.ceil(n/cols);
    const cellW = (cw - pad*2) / cols;
    const cellH = (ch - pad*2) / rows;
    nodes.forEach((node, i) => {
      const c = i % cols;
      const r = Math.floor(i / cols);
      node.x = pad + c*cellW + cellW/2 + (Math.random()-0.5)*4;
      node.y = pad + r*cellH + cellH/2 + (Math.random()-0.5)*4;
    });
  }

  function layoutFocusNoOverlap(){
    const cw=canvas.width, ch=canvas.height, cx=cw/2, cy=ch/2;
    const parent = nodes[0];
    parent.x = cx; parent.y = cy;

    const kids = nodes.slice(1);
    if (!kids.length) return;

    const startRadius = 120, ringGap=90, minSepPx=12, labelPadPx=8;
    const needPx = (node) => Math.max(2*(node.size||7), measure.measureText(node.label||'').width + labelPadPx) + minSepPx;

    let ringIndex = 0, angleUsed = 0, R = startRadius;
    const TWO_PI = Math.PI*2, startAngle = Math.random()*TWO_PI;

    const order = kids.slice().sort((a,b)=> needPx(b) - needPx(a));
    for (const k of order){
      let spanPx = needPx(k);
      let ang = spanPx / R;
      while (angleUsed + ang > TWO_PI && ringIndex < 100){
        ringIndex++; R = startRadius + ringIndex*ringGap; angleUsed = 0; ang = spanPx / R;
      }
      const t = startAngle + angleUsed + ang/2;
      k.x = cx + R*Math.cos(t);
      k.y = cy + R*Math.sin(t);
      angleUsed += ang;
    }
    for (let i=1;i<nodes.length;i++){
      const n = nodes[i], dx=n.x-cx, dy=n.y-cy, r=Math.hypot(dx,dy);
      const jitter = (Math.random()-0.5)*2.0, t=Math.atan2(dy,dx);
      n.x = cx + (r+jitter)*Math.cos(t); n.y = cy + (r+jitter)*Math.sin(t);
    }
  }

  // ---------- zoom / pan ----------
  canvas.addEventListener('wheel', e=>{
    const m = e.deltaY>0 ? 0.9 : 1.1;
    const before = toGraph(e.offsetX, e.offsetY);
    scale *= m;
    const after = toGraph(e.offsetX, e.offsetY);
    tx += (after[0]-before[0])*scale;
    ty += (after[1]-before[1])*scale;
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('mousedown', e=>{
    const [gx,gy] = toGraph(e.offsetX, e.offsetY);
    const hit = pick(gx,gy);
    if (hit){
      dragging = hit; dragOffset=[gx-hit.x, gy-hit.y];
      showTip(hit, e.offsetX, e.offsetY);
      if (mode==='overview' && hit.group==='parent'){
        buildFocus(hit.label); mode='focus'; fitScreen();
        const sel = document.getElementById('parent-select'); if (sel) sel.value = hit.label;
      }
    } else {
      panning=true; panStart=[e.offsetX,e.offsetY]; panOrig=[tx,ty]; hideTip();
    }
  });
  window.addEventListener('mousemove', e=>{
    if (dragging){ const [gx,gy] = toGraph(e.offsetX, e.offsetY); dragging.x=gx-dragOffset[0]; dragging.y=gy-dragOffset[1]; showTip(dragging, e.offsetX, e.offsetY); }
    else if (panning){ tx = panOrig[0] + (e.offsetX - panStart[0]); ty = panOrig[1] + (e.offsetY - panStart[1]); }
  });
  window.addEventListener('mouseup', ()=>{ dragging=null; panning=false; });

  document.getElementById('fit').addEventListener('click', fitScreen);
  document.getElementById('mode-overview').addEventListener('click', ()=>{ buildOverview(); mode='overview'; fitScreen(); });
  document.getElementById('mode-focus').addEventListener('click', ()=>{
    const val = document.getElementById('parent-select').value;
    if (val){ buildFocus(val); mode='focus'; fitScreen(); }
  });
  document.getElementById('mode-network').addEventListener('click', ()=>{
    const n = +document.getElementById('net-count').value;
    buildNetwork(n); mode='network'; fitScreen();
  });
  document.getElementById('rerun').addEventListener('click', ()=>{
    if (!window.__DATA) return;
    if (mode==='network'){
      const n = +document.getElementById('net-count').value;
      buildNetwork(n); fitScreen();
    } else if (mode==='focus'){
      const val = document.getElementById('parent-select').value;
      if (val){ buildFocus(val); fitScreen(); }
    } else {
      buildOverview(); fitScreen();
    }
  });
  const sel = document.getElementById('parent-select');
  if (sel) sel.addEventListener('change', e=>{
    if (e.target.value){ buildFocus(e.target.value); mode='focus'; fitScreen(); }
  });
  document.getElementById('net-count').addEventListener('change', ()=>{
    if (mode==='network'){ const n = +document.getElementById('net-count').value; buildNetwork(n); fitScreen(); }
  });

  function toGraph(sx,sy){ return [(sx-tx)/scale, (sy-ty)/scale]; }
  function pick(x,y){ for (let i=nodes.length-1;i>=0;i--){ const n=nodes[i]; const dx=x-n.x, dy=y-n.y; const r=(n.size+6); if (dx*dx+dy*dy<=r*r) return n; } return null; }
  function showTip(n, sx, sy){ const lines=[(n.group==='parent'?'Parent':'Child')+': '+n.label]; if (n.cik) lines.push('CIK: '+n.cik); if (n.count!=null) lines.push('Links: '+n.count); tip.innerHTML=lines.join('<br/>'); tip.style.left=(sx+12)+'px'; tip.style.top=(sy-10)+'px'; tip.style.display='block'; }
  function hideTip(){ tip.style.display='none'; }

  // ---------- draw with label culling ----------
  function draw(){
    const bg = getComputedStyle(document.documentElement).getPropertyValue('--card').trim() || '#FFF';
    const parentCol = getComputedStyle(document.documentElement).getPropertyValue('--parent').trim() || '#D04A02';
    const childCol  = getComputedStyle(document.documentElement).getPropertyValue('--child').trim()  || '#00A3A1';
    const linkCol   = getComputedStyle(document.documentElement).getPropertyValue('--link').trim()   || '#C8C4BE';

    ctx.fillStyle=bg; ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.save(); ctx.translate(tx,ty); ctx.scale(scale,scale);

    // edges (visible for focus + network)
    if ((mode==='focus' || mode==='network') && links.length){
      const minEdgePx = 0.8;
      ctx.lineWidth = Math.max(minEdgePx/scale, 0.2/scale);
      ctx.strokeStyle = linkCol;
      ctx.beginPath();
      for (const e of links){ const s=e.source,t=e.target; if (!s||!t) continue; ctx.moveTo(s.x,s.y); ctx.lineTo(t.x,t.y); }
      ctx.stroke();
    }

    // nodes
    const minNodePx = 2;
    for (const n of nodes){
      const r = Math.max(n.size||7, minNodePx/scale);
      ctx.beginPath();
      ctx.fillStyle = (n.group==='parent' ? parentCol : childCol);
      ctx.arc(n.x,n.y,r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // labels (screen-space culling)
    const showLabels = (mode==='focus')
      ? (scale > 0.5 || nodes.length < 180)
      : (scale > 1.0 || nodes.length < 90);

    if (showLabels){
      measure.font = baseFont;
      const fontHeight = 14;
      const cands = nodes.map(n=>{
        const r_world = Math.max(n.size||7, minNodePx/scale);
        const y_world = n.y + r_world + 4;
        const w_world = measure.measureText(n.label||'').width;
        const w_screen = w_world * scale;
        const h_screen = fontHeight * scale;
        const sx = n.x*scale + tx;
        const sy = y_world*scale + ty;
        return { n, sx, sy, w:w_screen, h:h_screen };
      });

      cands.sort((a,b)=>{
        const gp = (a.n.group==='parent') - (b.n.group==='parent');
        if (gp) return -gp;
        const d = (b.n.count||0) - (a.n.count||0);
        if (d) return d;
        return a.w - b.w;
      });

      const placed = [];
      ctx.save();
      ctx.font = baseFont;
      ctx.textAlign='center';
      ctx.textBaseline='top';
      ctx.fillStyle='#333';

      for (const L of cands){
        const x0 = L.sx - L.w/2, y0 = L.sy, x1 = x0 + L.w, y1 = y0 + L.h;
        let overlaps = false;
        for (const P of placed){
          if (x0 < P.x1+2 && x1 > P.x0-2 && y0 < P.y1+2 && y1 > P.y0-2){ overlaps = true; break; }
        }
        if (!overlaps){
          placed.push({x0,y0,x1,y1});
          ctx.fillText(L.n.label, L.sx, L.sy);
        }
      }
      ctx.restore();
    }

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  function fitScreen(){
    if (!nodes.length){ return; }
    const cw=canvas.width, ch=canvas.height, cx=cw/2, cy=ch/2;
    const minx=Math.min(...nodes.map(n=>n.x)), maxx=Math.max(...nodes.map(n=>n.x));
    const miny=Math.min(...nodes.map(n=>n.y)), maxy=Math.max(...nodes.map(n=>n.y));
    const w=Math.max(1, maxx-minx), h=Math.max(1, maxy-miny);
    const s = 0.9 * Math.min(cw/w, ch/h);
    scale = isFinite(s) ? Math.min(Math.max(s, 0.1), 5) : 1;
    tx = cx - ((minx+maxx)/2)*scale;
    ty = cy - ((miny+maxy)/2)*scale;
  }
})();
</script>

<!-- Last push time (GitHub API). Set GH_OWNER/GH_REPO if autodetect fails. -->
<script>
const GH_OWNER = "";
const GH_REPO  = "";
(function () {
  const el = document.getElementById('gh-push');
  if (!el) return;
  let owner = GH_OWNER, repo = GH_REPO;
  if (!owner || !repo) {
    if (location.hostname.endsWith('.github.io')) {
      owner = owner || location.hostname.split('.github.io')[0];
      const parts = location.pathname.split('/').filter(Boolean);
      repo  = repo  || (parts[0] || `${owner}.github.io`);
    }
  }
  if (!owner || !repo) { el.textContent = 'unavailable'; return; }
  fetch(`https://api.github.com/repos/${owner}/${repo}`)
    .then(r => r.ok ? r.json() : Promise.reject())
    .then(meta => { el.textContent = new Date(meta.pushed_at).toLocaleString(); })
    .catch(() => { el.textContent = 'unavailable'; });
})();
</script>
</body>
</html>
